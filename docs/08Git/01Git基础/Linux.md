## 1 linux 文件/目录

1、**Linux文件系统具有层级性**

1）文件或者目录起始于根目录“/”成为树状结构

2）最顶层由/开始

2、linux文件和目录名区分大小写，win下不分区大小写

3、路径通过“/”分隔开

4、“…”表示上层目录

5、“.”表示当前目录

6、隐藏目录或者文件名以“.”开始

**除了/外，所有的字符都合法**

1）避免文件名首字符使用±.等，因为.是隐藏文件

2）避免使用空格、制表符和@#$%等

### **重要目录说明：**

1、**home目录**

1）root用户的home目录是/root

2）普通用户的目录是/home/userx

2、**bin目录**

1）常用的可执行文件

2）/bin、/usr/bin、/sbin等

3、**外部设备mountpoint**

1）/media/mnt

2）当检测到设备接入会自动产生挂载点

4、/etc，系统的配置文件

5、/tmp，临时文件。任何用户都能访问

6、/boot，系统内核和开机必要文件

7、/dev，系统所有的设备文件

8、**/usr**

1）unix system resource

2）保存程序的相关文件

**c语言的标准头文件stdio.h等头文件在/usr/include下**

9、**/lost+found**

1）每个分区都会自动创建

10、/var、/srv

11、/proc

12、/lib、/usr/lib、/usr/locat/lib

## 2 磁盘：安系统分区注意事项

| 挂载点 | 建议大小 | 格式         | 作用                                                         |
| ------ | -------- | ------------ | ------------------------------------------------------------ |
| /      | 20G      | ext4         | 根目录                                                       |
| /home  | 越大越好 | ext4         | 一般个人文件都存放在这里                                     |
| /boot  | 300M     | ext4         | 主要存放linux内核及一些引导文件，系统启动时需要的内存，几百M已不够 |
| /tmp   | 10G      | ext4         | 系统的临时文件                                               |
| /swap  | 8G       | swap交换空间 | 相当于虚拟内存，建议和内存一样大                             |

1磁盘分区类型

 1主分区：最多有4个

分区表64B，记录了每个磁盘的区间，每记录一个分区的位置需要16B，所以最多4个

 2扩展分区，逻辑分区

为了多余4个分区，cd盘不变

linux下硬盘命名方式

 1 IDE硬盘->hd[a-d]

 2 SATA硬盘->[a-d]

## 3 基本指令

hostname 计算机名（root）

halt 关机

reboot 重启

#### 0、帮助命令：

```bash
# 当我们对某个指令不熟悉时，我们可以使用 Linux 提供的帮助指令来了解这个指令的使用方法。
man [命令或配置文件]（功能描述：获得帮助信息）

help 命令 （功能描述：获得 shell 内置命令的帮助信息）
1234
```

#### sudo

`sudo + 其他命令`：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。

#### 1、`ls`

```bash
ls [选项] [目录或文件]
ls:列出当前目录内容，文件白色，目录蓝色
-a 显示隐藏文件
–l，显示详细内容
–ld，显示目录本身的属性
-lh 路径，才能查看文件大小，否则查看的是文件夹大小

# 常见用法
ll # 群主 大小  时间 文件
ls |grep
12345678910
```

#### cd

1）cd、pwd : change directory ,print work directory

2）cd…，cd ~ : 家目录 , cd - ：上次使用的目录

#### cp

```BASH
cp [选项] 源文件 目的目录
-p不更改时间，
-r目录下内容也赋值，递归复制整个文件夹
123
```

#### mv

```BASH
#重命名a到b
mv a.txt b.txt
#移动文件
mv a.txt 目的目录
1234
```

#### rm rmdir

```bash
#删除文件
rm [options] filenames
#删除空目录
rmdir 目录名
#删除非空目录
rmdir -rf 目录名
-i，交互式，询问 
-r递归删除
-f，force  不经确认直接删掉 
123456789
```

提示：如果需要删除非空目录，需要使用 rm -rf 要删除的目录

#### 新建

```BASH
#新建文件
touch a.txt
#新建目录
mkdir 目录名
#递归创建目录
mkdir -p 目录名
123456
```

- **`cat`：** 查看显示文件内容
- **`more`：** 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看
- **`less`：** 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看
- **`tail-10` ：** 查看文件的后10行，Ctrl+C结束

#### cat

```bash
cat [选项] 文件
-n显示行号

分页显示文件：
cat 文件 | more # 查看文件信息并通过more分页显示
12345
```

cat只能浏览文件，不能修改文件。可以指定显示的行数：通过管道命令|more

#### more

more用来分页显示文件

```bash
more 文件名
ps -ef |less  # 查看进程信息并通过less分页显示
12
```

| more操作 | 说明            |
| -------- | --------------- |
| 空格     | 下翻一页        |
| 回车     | 下一行          |
| q        | 退出            |
| Ctrl+F   | 下滚动一屏      |
| Ctrl+B   | 上滚动一屏      |
| =        | 输出当前行号    |
| :f       | 输出文件名+行号 |

| less操作   | 说明           |
| ---------- | -------------- |
| 空格、回车 | 下一页、下一行 |
| pagedown   | 下一页         |
| pageup     | 上一页         |
| /          | 向下查找       |
| ?          | 向上查找       |
| q          | 退出           |

more 和 less的区别:

1. less可以按键盘上下方向键显示上下内容,more不能通过上下方向键控制显示
2. less不必读整个文件，加载速度会比more更快
3. less退出后shell不会留下刚显示的内容,而more退出后会在shell上留下刚显示的内容

#### head/tail

head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容。，Ctrl+C结束

命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控文件的变化

```BASH
head  文件	(功能描述：查看文件头 10 行内容)
head -n 5 文件	(功能描述：查看文件头 5 行内容，5 可以是任意行数)

tail用法同
1234
```

#### vim

```bash
/ 向下查找
? 向上查找
dd # 删除所在行
yy # 复制所在行
p # 粘贴在下一行
P # 粘贴在上一行
u # 恢复
Ctrl+r # 重做
:set nu # 显示行号
==【h、j、k、l】==，分别控制光标左、下、上、右移一格
12345678910
```

- **`ps -ef`和`ps -aux`：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**`ps aux|grep redis`** （查看包括redis字符串的进程），也可使用 `pgrep redis -a`。

  注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。

- **`kill -9 进程的pid`：** 杀死进程（-9 表示强制终止。）

  先用ps查找进程，然后用kill杀掉

- **网络通信命令：**

  - 查看当前系统的网卡信息：ifconfig
  - 查看与某台机器的连接情况：ping
  - 查看当前系统的端口使用：netstat -an

- **net-tools 和 iproute2 ：**
  `net-tools`起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持`iproute2`。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读[如何在Linux中使用IP命令和示例](https://linoxide.com/linux-command/use-ip-command-linux)

- **`shutdown`：** `shutdown -h now`： 指定现在立即关机；`shutdown +5 "System will shutdown after 5 minutes"`：指定5分钟后关机，同时送出警告信息给登入用户。

- **`reboot`：** **`reboot`：** 重开机。**`reboot -w`：** 做个重开机的模拟（只有纪录并不会真的重开机）。

#### 重定向>和追加>>

```bash
> 输出重定向 : 会将原来的文件的内容覆盖
>> 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部。
<  将文件作为命令输入 :
mysql -u root -p -h test < test.sql
# “命令 < 文件1 >文件2” 将文件1输入到命令中，然后将结果输出到文件2中

ls -l >文件（功能描述：列表的内容写入文件 a.txt 中（覆盖写））
ls -al >>文件	（功能描述：列表的内容追加到文件 aa.txt 的末尾）
cat 文件 1 > 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2）
123456789
```

追加命令可以和下面的echo命令做一些特殊的事情

#### 数字/输出echo

echo 输出内容到控制台。

```BASH
echo	[选项]	[输出内容]
1
vim test.sh 
# 该文件有如下内容
/*
#!/bin/sh
echo "shell脚本本身的名字: $0"
echo "传给shell的第一个参数: $1"
echo "传给shell的第二个参数: $2"
*/

# 执行
./test.sh 1 2 
shell脚本本身的名字: ./test.sh 
传给shell的第一个参数: 1 
传给shell的第二个参数: 2 
1234567891011121314
```

#### `command>/dev/null 2>&1`

常见的`command>/dev/null 2>&1`是什么意思

- 0 表示stdin标准输入
- 1 表示stdout标准输出
- 2 表示stderr标准错误

前半句分析：`command>/dev/null`代表将命令指向结果指向结果重定向到null设备中。等价于`command 1 > /dev/null`

后半句分析：

`&`**等效于标准输出**

`command 1>a 2>&1`与`command 1>a 2>a`还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。`&1`的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，`command 1>a 2>&1`比`command 1>a 2>a`的效率更高。

#### history

#### ln

- 软链接(符号链接)：类似于 windows 里的快捷方式，主要存放了链接其他文件的路径
- 硬链接：同步更改，但没什么用。硬链接只能链接文件，不能链接目录

```bash
硬链接：
ln 源文件 链接文件
软连接：
ln -s 源文件  链接文件
1234
```

#### 搜索

##### grep：文本搜索

- grep 过滤查找
- 管道符“|”：表示将前一个命令的处理结果输出传递给后面的命令处理。

```bash
grep [选项] 查找内容 源文件
-n ， 显示匹配行号
-i ， 忽略大小写

示例：查找hello.txt中aaa字符
cat hello.txt | grep aaa

通配符：
*全部  ^a以a为开头  K$以k为结尾  [0-9]可选  .匹配一个字符（而不是？问号）
123456789
```

##### find目录搜索

find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。

```BASH
find 搜索目录 [选项]
-name，按文件名查找
-user，按所属用户查找
-size，按文件大小查找

示例：
find ./ -name *.c
find ./ -size +2M 查找大于2M的文件
12345678
```

locate

locate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。

#### 压缩/解压

```BASH
tar：只进行打包、解包，不进行压缩大小。文件名可以带路径
tar [参数] 打包目的文件名
-c ，打包成.tar
-v ，显示详细信息
-f ， 指定压缩后文件名
-z ， 打包同时压缩
-x ， 解压tar包
压缩：`tar -cvf xxx.tar  需要打包的文件`
解压:`tar -xvf xxx.tar`    
----------------------
gzip：会压缩空间
`gzip xxx.tar`自动在当前目录生成xxx.tar.gz    -r有没有都一样
解压：`gzip -d xxx.tar.gz`
----------------------
zip：
zip	[选项] XXX.zip	将要压缩的内容（功能描述：压缩文件和目录的命令）
unzip	[选项] XXX.zip （功能描述：解压缩文件）

123456789101112131415161718
```

#### `which 命令`

用查看命令在哪个位置

#### **切换用户su**

sudo su

```sh
uptime #查看系统启动时间
1
```

系统平均负载：运行队列进程数/总时间。

如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。如果你的linux主机是1个双核CPU的话，当Load Average 为6的时候说明机器已经被充分使用了。

## 4 bash命令

```php
php中
$cmd = "ffmpeg -i $videoPath 2>&1 | perl -ne 'if(/Stream\s+#\d+:\d+.+,\s+(\d+)(.\d+)?\s+fps,/){print \"\$1\";}'";
12
```

匹配`Stream #0:0(und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x720 [SAR 1:1 DAR 16:9], 1347 kb/s, 24 fps, 24 tbr, 24 tbn, 48 tbc (default)`

输出24

```php
对应关系如下：
/Stream\s+#\d+:\d+.+                           ,\s+(\d+)(.\d+)?\s+fps,/
 Stream   #0  :0  (und): Video: h264 (High) (avc1 / 0x31637661), yuv420p, 1280x720 [SAR 1:1 DAR 16:9], 1347 kb/s,     24           fps, 24 tbr, 24 tbn, 48 tbc (default)`
123
```

#### 举个栗子

来个shell

```bash
//test.sh
#!/bin/sh
t
date
1234
```

`chmod +x test.sh`为test.sh增加执行权限。这里我们弄了两条命令，其中t指令并不存在，执行会报错，会输出到stderr。date能正常执行，执行会输出当前时间，会输出到stdout。

执行`./test.sh > res1.log`结果为

我们发现stderr并没有被重定向到res1.log中，stderr被打印到了屏幕上。这也进一步证明了上面说的`./test.sh > res1.log`等价于`./test.sh 1>res1.log`

执行`./test.sh>res2.log 2>&1`结果为

这次我们发现stdout和stderr都被重定向到了res2.log中了。上面我们未对stderr也就是2说明如何输出，stderr就输出到了屏 幕上，这里我们不仅对stdout进行说明，重定向到res2.log中，对标准错误也进行了说明，让其重定向到res2.log的引用即 res2.log的文件描述符中。

#### 再思考一下

为何2>&1要写在command>1的后面，直接用2可以么。比如`ls 2>a`。其实这种用法也是可以的，ls命令列出当前的目录，用stdout（1）表示，由于这个时候没有stderr(2)，这个时候执行`ls 2>a`也会正常产生一个a的文件，但是a的文件中是空的，因为这时候执行ls并没有产生stderr(2)。

## ubuntu循环登录的解决

**原因：NVIDIA 驱动所致，可能之前安装方式nvidia驱动方式不对，安装OpenGl导致？。**

（1）进入文本模式：CTRL+ALT+F1

（2）Uninstall any previous drivers:

```
sudo apt-get remove nvidia-*sudo apt-get autoremove
```

（3）Uninstall the drivers from the .run file:

```
sudo nvidia-uninstall
```

（4）此时，重启可login normally.

（5）驱动重新安装：

```
Ctrl+Alt+F1 
(2)sudo service lightdm stop 
(3)sudo ./NVIDIA-Linux-x86_64-381.22.run -no-x-check -no-nouveau-check -no-opengl-files
123
```

-no-x-check安装驱动时关闭x服务;

-no-nouveau-check 安装驱动时禁用Nouveau

-no-opengl-files 安装时只装驱动文件，不安装Opengl

（6）sudo service lightdm restart（可正常登录）

# 一、用户管理

1. Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
2. Linux 的用户需要至少要属于一个组。

### 1.1 用户修改

```bash
# 添加用户
useradd  [选项]  用户名

# 给用户指定或者修改密码

passwd 用户名
# 删除用户
userdel 用户名
# 默认是不删除加目录的，如果要删除家目录：
userdel -r 用户名

# 查询用户信息。 当用户不存在时，返回”无此用户”
id  用户名

# 切换用户
su  -  要切换的用户名
12345678910111213141516
```

如果没有指定该用户所在组，则系统会自动创建一个与用户名同名的组，将该用户放入其中。

1. 当创建用户成功后，会自动的创建和用户同名的家目录 2) 也可以通过 useradd -d 指定目录 新的用户名，给新创建的用户指定家目录

在操作 Linux 中，如果当前用户的权限不够，可以通过 `su -` 指令，切换到高权限用户，比如 root

1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。

2)当需要返回到原来用户时，使用 exit 指令

### 1.2 用户组

类似于角色，系统可以对有共性的多个用户进行统一的管理。

```bash
# 添加组
groupadd 组名

# 删除组
groupdel 组 名

# 创建用户时直接加上组
useradd  -g 用户组 用户名

# 修改组
usermod  -g 用户组 用户名
1234567891011
```

### 1.3 配置文件

- 用户配置文件/etc/passwd

用户（user）的配置文件，记录用户的各种信息

每行的含义：

用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell

- 口令配置文件/etc/shadow

每行的含义：
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志

- 组配置文件/etc/group

组(group)的配置文件，记录 Linux 包含的组的信息每行含义：组名:口令:组标识号:组内用户列表

# 二、 权限管理

Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。

在 linux 中的每个用户必须属于一个组，不能独立于组外。

1. 所有者：谁创建
2. 所在组
3. 其它组

### 2.1 所有者

一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。

```BASH
# 查看所有者
ls  -ahl
# 修改所有者
chown 用户名 文件名
1234
```

### 2.2 组

创建文件的用户所在组即文件的默认组

每个User都属于一个Group，具有唯一的标识符gid

```BASH
# 创建组
groupadd 组名
# 查看所有组
ls  -ahl
# 更改所有组
chgrp 组名 文件名

# 更改用户所在组
usermod	–g	组名	用户名
# 改变该用户登陆的初始目录。
usermod  –d 目录名 用户名 
1234567891011
```

### 2.3 查看权限

```BASH
#查看权限
ls -l ， 查看当前目录所有文件权限
12
```

返回内容类似于
`-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc`
重点是：-rwxrw-r–

- 第0 位确定文件类型：文件 (-)，目录(d)，软链接(l)
- 1-3 位：所有者权限
- 4-6位：所有组权限
- 7-9位：其他组权限

rwx代表：

- r(read)：可读，可以读取，查看。4
- w(write)：可写，可以修改/重命名。但未必可删除。删除前提是有写权限。2。
- x(execute)：可执行。1

对于文件：

| 权限名称 | 可执行操作                |
| -------- | ------------------------- |
| r        | 可以使用cat查看文件的内容 |
| w        | 可以修改文件的内容        |
| x        | 可以将其运行为二进制文件  |

对于目录：

| 权限名称 | 可执行操作               |
| -------- | ------------------------ |
| r        | 可以查看目录下列表       |
| w        | 可以创建和删除目录下文件 |
| x        | 可以使用cd进入目录       |

### 2.4 修改权限-chmod

**需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。**
**在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。**

- u 表示该文件的拥有者，
- g 表示与该文件的拥有者属于同一个群体(group)者，
- o 表示其他以外的人，
- a 表示这三者皆是。

```BASH
# 添加/删除/修改权限
# 1.更改全部
chmod [-cfvR] [--help] [--version] mode file...
# 2.指定修改
chmod u=rwx,g=rx,o=x 文件目录名
chmod -R u=rwx,g=rwx,o=rwx ./log # // 递归给log目录下的所有文件授权
示例：添加写权限
chmod u+w hello.txt
# 修改所有者，可以-r递归
chown newowner file  改变文件的所有者
# 修改所有组
chgrp newgroup file	改变文件的所有组
------------
# 3.也可通过数字更改
r=4 w=2 x=1
chmod u=rwx,g=rx,o=x hellp.txt
可转化为
chmod 751 hello.txt
123456789101112131415161718
```

| Who  | 操作 | permission | digit |
| ---- | ---- | ---------- | ----- |
| U    | +    | r 读       | 4     |
| G    | -    | w 写       | 2     |
| O    | =    | x 可执行   | 1     |
| A    |      | -          | 0     |

root：

1）超级管理员账号，具有至高无上的权限

2）一般不要随便用root登录并操作系统

# 进程管理

### 11 crond 任务调度

crontab 进行 定时任务的设置，。

任务调度：是指系统在某个时间执行的特定的命令或程序。

任务调度分类：

1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等

2.个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。

```bash
crontab [选项]
-e ， 编辑定时crontab任务
-i ， 查询crontab任务
-r ， 删除用户所有crontab任务
1234
```

任务的要求：

设置任务调度文件：/etc/crontab

设置个人任务调度。执行 crontab –e 命令。接着输入任务到调度文件

如：*/1 * * * * ls –l /etc/ > /tmp/to.txt

意思说每小时的每分钟执行 ls –l /etc/ > /tmp/to.txt 命令

步骤如下：

1. cron -e
2. */ 1 * * * * ls -l /etc >> /tmp/to.txt
3. 当保存退出后就程序。
4. 在每一分钟都会自动的调用 ls -l /etc >> /tmp/to.txt

案例 1：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中

1. 先编写一个文件 /home/mytask1.sh date >> /tmp/mydate
2. 给 mytask1.sh 一个可以执行权限

chmod 744 /home/mytask1.sh

1. crontab -e打开后编辑如下内容

```
*/1 * * * * /home/mytask1.sh
```

## 11.6 crond 相关指令:

1. conrtab –r：终止任务调度。
2. crontab –l：列出当前有那些任务调度
3. service crond restart [重启任务调度]

# 第 12 章 linux 磁盘分区、挂载

- 文件都要挂载根目录/下

## 1 查看硬盘号

1)Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘

2)对于 IDE 硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。

- “x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）
- “~”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。
- 例，hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区。

3)对于SCSI硬盘则标识为"sdx~"，SCSI硬盘是用"sd"来表示分区所在设备的类型的，其余则和 硬盘的表示方法一样。

```BASH
# 查看分区/挂载情况
lsblk
lsblk -f
行尾的目录显示的是挂载的目录（挂载点）
1234
```

## 2 挂载硬盘

需求：挂载硬盘到/home/newdisk

步骤：

- 插入硬盘
- 分区硬盘
- 格式化硬盘
- 挂载
- 修改配置永久挂载

### 2.1 插入硬盘/添加虚拟机硬盘

如果你是真实硬盘，请跳过这步。

虚拟机添加硬盘方法：在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）！

### 2.2 给硬盘分区

输入`lsblk -f`可以看到我们新增的磁盘sdb1

输入分区命令：

```BASH
fdisk  /dev/sdb
开始对/sdb 分区
然后依次输入下面
开始分区后输入 n，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出（若不保存退出输入q）。
m  显示命令列表
p 显示磁盘分区 同 fdisk –l
n  新增分区
d 删除分区
w  写入并退出
123456789
```

此时输入lsblk -f还是不显示一大串ID

### 2.3格式化磁盘

```BASH
mkfs -t  ext4  /dev/sdb1
# 意思为把 /dev/sdb1 设备格式化为ext4分区类型
12
```

格式化后再输入lsblk -f ，就显示一大串ID了

### 2.4 挂载

挂载: 将一个分区与一个目录联系起来，

先创建所需要的下载目录，比如要挂载到/home/newdisk

```BASH
mkdir /home/newdisk
# 把硬盘设备挂载到创建的目录中
mount  设备名称   挂载目录
mount /dev/sdb1  /home/newdisk
# 如果需要卸载的话，卸载
umount 设备名称/或挂载目录
umount /dev/sdb1 或者  umount /newdisk
1234567
```

### 2.5 永久挂载

之前配置的是临时挂载，重启机器就会失效。所以需要修改成永久挂载。

```BASH
vim /etc/fstab
添加一行
/dev/sdb1  /home/newdisk  ext4  default 0 0

执行下面命令使生效
mount –a
123456
```

## 3 磁盘情况查询

```BASH
# 查询系统整体磁盘使用情况
df -h

# 查询指定目录的磁盘占用情况
du -h  /目录
-s 指定目录占用大小汇总
-h 带计量单位
-a 含文件
--max-depth=1  子目录深度
-c 列出明细的同时，增加汇总值
12345678910
```

## 4 磁盘情况-工作实用指令

```BASH
1) 统计/home 文件夹下文件的个数

2) 统计/home 文件夹下目录的个数

3) 统计/home 文件夹下文件的个数，包括子文件夹里的

4) 统计文件夹下目录的个数，包括子文件夹里的

5) 以树状显示目录结构
123456789
```

# 第 13 章 linux网络配置

目前我们的网络配置采用的是 NAT。

虚拟机IP的问题：

- windows上有两个网域，一个是正常的真实网卡比如192.168.111.111，另外一个是虚拟网卡vmnet8，如192.168.222.21，而linux虚拟机配置的IP为192.168.222.22，此时linux的IP与windows的虚拟网卡vmnet8在同一网段，所以可以通信。而比如在同一办公室路由器下面的隔壁电脑IP为192.168.111.112，所以拟合隔壁也能通信。而百度是由网关转发出去的，所以虚拟机和windows的网关都是一样的。

## 1 查看网络 IP 和网关

查看虚拟网络编辑器：VM中–编辑—虚拟网络编辑器

修改 ip 地址(修改虚拟网络的 ip)：网关：NAT设置–网关

查看 windows 环境的中 VMnet8 网络配置 (ipconfig 指令)

- 使用 ipconfig 查看
- 网络界面查看

```sh
# 查看端口情况
netstat -ntlp | grep 80

#查看到进程占用的端口号
netstat -anp | grep pid

netstat命令各个参数说明如下：
　　-t : 指明显示TCP端口
　　-u : 指明显示UDP端口
　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)
　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。
　　-n : 不进行DNS轮询，显示IP(可以加速操作)
　　
　　
sudo vim /etc/network/interfaces
auto eno1 # 让网卡开机自动挂载
iface eno1 inet static

address 192.168.10.19 #内网IP
netmask 255.255.255.0 # 通用
gateway 192.168.10.1 # 与address只有最后一个不一样

network 192.168.10.0网络地址
broadcast 192.168.10.255  广播
123456789101112131415161718192021222324
```

## 2 linux 网络环境配置

方法一：自动获取IP（DHCP），每次重启的IP都会改变

方法二：设置固定IP，

编辑`/etc/sysconfig/network-scripts/ifcfg-eth0`（对于centos系统）

重启网络：service network restart

修改后，一定要重启服务

1. service network restart
2. reboot 重启系统

# 第 14 章 linux进程管理

1)在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号。

2)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如 www 服务器。

3)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。

4)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。

## 1 显示系统执行的进程

```BASH
# 显示进程
ps -aux

#显示当前终端所有进程信息
ps -a
12345
```

返回参数：

- User用户
- PID：进程ID
- %CPU：占用CPU情况
- %MEM：占用内存情况
- VSZ：进程占用的虚拟内存大小（单位：KB）
- RSS：进程占用的物理内存大小（单位：KB）
- TT：终端名称,缩写 .
- STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等
- STARTED：进程的启动时间
- TIME：CPU 时间，即进程使用 CPU 的总时间
- COMMAND：启动进程所用的命令和参数，如果过长会被截断显示

```BASH
ps -ef | more
ps -ef | grep 进程名
-e：显示所有进程
-f：全格式
返回:
UID PID PPID C STINE TTY TIME CMD
PID是进程号  PPID是父进程
1234567
```

- UID：用户 ID
- PID：进程 ID
- PPID：父进程 ID
- C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高
- STIME：进程启动的时间
- TTY：完整的终端名称
- TIME：CPU 时间
- CMD：启动进程所用的命令和参数

## 2 终止进程 kill 和 killall

若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务。

```BASH
# 通过进程号杀死进程
kill [选项] PID进程号
-9 :表示强迫进程立即停止

# 通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用
killall 进程名称
123456
```

## 3 查看进程树 pstree

```BASH
pstree [选项] 
-p :显示进程的 PID
-u :显示进程的所属用户 
123
```

树状的形式进程的用户 id pstree -u 即可。

## 4 服务(Service)管理

服务service本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如 , 防火墙等，因此我们又称为守护进程，是linux中非常重要的知识点。

> 在 CentOS7.0 后 不再使用 service ,而是 systemctl

```BASH
# 查看当前防火墙的状况，关闭防火墙和重启防火墙
service iptables status
service iptables stop
service iptables start
# service这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。
# 如果希望设置某个服务自启动或关闭永久生效，要使用 chkconfig 指令 
123456
```

#### 查看服务名：

- 方式 1：终端输入setup -> 系统服务 就可以看到。
- 方式2：/etc/init.d/ 目录下查看

### chkconfig命令

chkconfig需要先了解运行级别。每个服务都可以设置在哪个级别下自启动。

Linux 系统有 7 种运行级别(runlevel)：常用的是级别 3 和 5

```BASH
# 通过 chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭

# 查看全部服务运行级别
chkconfig --list
# 查看部分服务于运行级别
chkconfig --list | grep xxx

# 设置运行级别
chkconfig --level 5 服务名  on/off
# 设置所有级别
chkconfig  服务名  on/off

# chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 才能生效.
12345678910111213
```

- 运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动
- 运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆
- 运行级别 2：多用户状态(没有 NFS)，不支持网络
- 运行级别 3：完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式
- 运行级别 4：系统未使用，保留
- 运行级别 5：X11 控制台，登陆后进入图形 GUI 模式
- 运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动

## 5 动态监控进程

top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程

```BASH
top [选项]
-d 指定刷新时间
-i 使top不显示任何限制或者僵死进程
-p 通过制定监控进程ID来仅仅监控某个进程的状态


交互操作说明：
P  以CPU使用率排序（默认）
M  以内存使用率排序
N  以PID排序
q  退出top
u  查看指定用户
k  终止指定的进程
12345678910111213
```

### 查看网络情况 netstat(重要)

```BASH
netstat [选项]

netstat -anp
-an  按一定顺序排列输出
-p  显示哪个进程在调用

netstat -anp | grep sshd
```